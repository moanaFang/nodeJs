<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>async-await04</title>
</head>
<body>
  <script>
// 匿名函式

  // scope

    // console.log(1); //全域變數

    // (async function() {
    //   console.log(2);
    // })(); //區域變數，不會影響到全域變數


    // (function() {

    // }());

    // (async () => {

    // })();

    
    function myPromise() {
      return new Promise((resolve,reject) => {
        const rnd = Math.random() * 1500;
        setTimeout(() => {
          resolve(rnd);
        }, rnd);
      });
    }

  // then 不可以用迴圈處理， async 可以
    // (async () => {
    //   const r1 = await myPromise();
    //   console.log(1, r1);
    //   console.log(2, await myPromise());
    //   console.log(3, await myPromise());
    //   console.log(4, await myPromise());
    //   console.log(5, await myPromise());
    // })();

  // 方法一
  // 無法確保async外面的執行順序
    // (async () => {
    //   for(let i = 1; i <= 10; i++) {
    //     console.log(i, await myPromise());
    //   }
    // })();
 
    // (async () => {
    //   for(let i = 1; i <= 10; i++) {
    //     console.log(String.fromCharCode(64 + i), await myPromise());
    //   }
    // })();

  // 方法二
  // async內會依照順序執行
    // (async () => {
    //   for(let i = 1; i <= 10; i++) {
    //     console.log(i, await myPromise());
    //   }
    //   for(let i = 1; i <= 10; i++) {
    //     console.log(String.fromCharCode(64 + i), await myPromise());
    //   }
    // })();

  // 方法三
  (async () => {
      for(let i = 1; i <= 10; i++) {
        console.log(i, await myPromise());
      }
      
    })()
    .then(async () => {
        for(let i = 1; i <= 10; i++) {
          console.log(String.fromCharCode(64 + i), await myPromise());
        }
      });
  </script>
</body>
</html>